diff a/Processing/data_parsing_gallup.py b/Processing/data_parsing_gallup.py	(rejected hunks)
@@ -1,4 +1,3 @@
-from __future__ import print_function  # needed to print without newline, imported from Python 3.x
 import json
 import csv
 import os
@@ -6,9 +5,7 @@
 
 FOCUS = "teams"  # can be "single_players" or "teams"
 FILE_SEPARATOR = ".csv"  # input files must have the .csv extension, otherwise the csv reader does not work
-EVENTS_TO_PROCESS = {"round+risk"}  # events that can be processed:
-# "gold", "round", "distance", "risk", "voting_st_dev", "risk_aversion", "round+risk"
-SIMPLE_STATE_CRITERION = False  # used to determine which add_event function to use
+EVENTS_TO_PROCESS = {"risk"}  # events that can be processed: "gold", "round", "distance", "risk", "voting_st_dev", "risk_aversion"
 CHOSEN_FILENAME = ""  # write a string to override the output file name equal to the source file name
 EVENT_COLUMN = 0  # column containing the events (including player actions)
 ITEM_NAME_COLUMN = 2  # column where items' names are written during setup
@@ -158,7 +155,7 @@
     return x if x % GOLD_INCREASE == 0 else x + GOLD_INCREASE - x % 100
 
 
-def add_event(event, quantity, target, trajectory, action_sequence, items_selected = None, success_chance = None):
+def add_event(event, quantity, target, trajectory, action_sequence, items_selected, success_chance):
     """
     :param event: the event to look up in the states
     :param quantity: the quantity we need to associate with the state
@@ -423,8 +382,12 @@
     # 2. No start end involved
     diff = 0
     # different Activity means different screens: diff is 1
-    if state1['round'] != state2['round']:
-        return INFINITE_DISTANCE
+    ###### Problem here: I have a field specify this node belongs which round.
+    ###### So I can compare nodes only in the same round.
+    ###### But it seems that you do not have this field.
+    ###### So what should we do with this?
+    # if state1['round'] != state2['round']:
+    #     return INFINITE_DISTANCE
 
     # # additional considerations can be done here
     elif state1['details']['event_type'] != state2['details']['event_type']:
@@ -521,10 +484,10 @@
         selected_items_quotient_sum = 0
         num_of_items = 0
         item1 = ""
+        item2 = ""
         item1_prob = 0
         item2_prob = 0
         voted_items = []
-        selected_probabilities = []
         initial_team = ""
 
         # initialize trajectory, action sequence and key
@@ -560,9 +523,6 @@
                         # clear the mining tools
                         MINING_TOOLS.clear()
 
-                        # temporary
-                        print_risk_sequences(selected_probabilities)
-
                     # reinitialize variables
                     gold_counter = 0
                     round_counter = 1
@@ -574,7 +534,6 @@
                     item1_prob = 0
                     item2_prob = 0
                     voted_items = []
-                    selected_probabilities = []
 
                     # reinitialize trajectory, action sequence and key
                     trajectory = [0]  # initialize with start state
@@ -593,10 +552,11 @@
 
                 if event == "ItemSetup":
                     MINING_TOOLS[row[ITEM_COLUMN]] = row[ITEM_PROBABILITY_COLUMN]
+
                     # print ("MINING_TOOLS: " + str(MINING_TOOLS))
                 elif event == "MineSetup":
                     prob_string = row[ITEM_PROBABILITY_COLUMN]
-                    # mines have a min and max probability of success: we store their average in MINING_TOOLS
+                    # mines have a min and max probability of success: we store their mean in MINING_TOOLS
                     prob_list = prob_string.translate(None, '()').split()
                     floor = float(prob_list[0])
                     ceiling = float(prob_list[1])
@@ -660,17 +620,18 @@
                             risk = "high"
                         else:
                             risk = "low"
-                        selected_probabilities.append(risk)
                         # print("-------------- SELECTED item risk: " + risk)
-                        # print("item1_prob: " + str(item1_prob) + ", " "item2_prob: " + str(item2_prob))
-
+                        print("item1_prob: " + str(item1_prob) + ", " "item2_prob: " + str(item2_prob))
+
+                        # num_of_items = num_of_items + 1
+                        # probability_quotient = float(MINING_TOOLS[item]) / mining_tools_prob_sum
+                        # selected_items_quotient_sum = selected_items_quotient_sum + probability_quotient
+                        # selection_counter = selection_counter + 1
+                        # print("... probability_quotient: " + str(probability_quotient))
+                        # print("... sum of probability quotients: " + str( selected_items_quotient_sum))
                         if "risk" in EVENTS_TO_PROCESS and risk != "":
-                            if SIMPLE_STATE_CRITERION:
-                                event_to_add = "r" + str(round_counter) + ":" + "risk " + risk
-                                add_event_string_based(event_to_add, "mid", team, trajectory, None)
-                            else:
-                                add_event("risk", risk, team, trajectory, None, items_selected, risk)
-                                # print("_______ added risk event: " + team + " risk: " + risk)
+                            add_event("risk", risk, team, trajectory, None, items_selected, risk)
+                            # print("_______ added risk event: " + team + " risk: " + risk)
 
                 if "gold" in EVENTS_TO_PROCESS and event == "TotalGold":
                     gold_counter = process_gold(row, TOTAL_GOLD_COLUMN, False, gold_counter, team, trajectory, event_sequence)
@@ -699,24 +660,10 @@
 
                             # add the round event and avoid updating action sequence because rounds are not team's actions
                             if "round" in EVENTS_TO_PROCESS:
-                                if SIMPLE_STATE_CRITERION:
-                                    event_to_add = "round " + str(round_counter)
-                                    add_event_string_based(event_to_add, "round", team, trajectory, None)
-                                else:
-                                    add_event("round", round_counter, team, trajectory, None, items_selected,
-                                              risk_aversion)
-                                    # print("added round event num: " + str(round_counter))
-                                    # print(">>>>>>>>>> avg_selected_item_success_prob: " + str(avg_selected_item_success_prob))
-                                    # print(">>>>>>>>>> risk_aversion: " + risk_aversion)
-
-                            # add the round+risk event
-                            if "round+risk" in EVENTS_TO_PROCESS and selected_probabilities.__len__() > 0:
-                                if SIMPLE_STATE_CRITERION:
-                                    event_to_add = "round+risk" + str(round_counter) + ": " + str(selected_probabilities)
-                                    add_event_string_based(event_to_add, "mid", team, trajectory, None)
-                                    print("...... ADDED round+risk event: " + str(round_counter) + ": " + str(selected_probabilities))
-                                    # reset the list of selected probabilities
-                                    selected_probabilities = []
+                                add_event("round", round_counter, team, trajectory, None, items_selected, risk_aversion)
+                                # print("added round event num: " + str(round_counter))
+                                # print(">>>>>>>>>> avg_selected_item_success_prob: " + str(avg_selected_item_success_prob))
+                                # print(">>>>>>>>>> risk_aversion: " + risk_aversion)
 
                         round_counter = round_counter + 1
 
@@ -728,9 +675,6 @@
                 PROCESS_CURRENT_TEAM = False
                 # print ("!!!!!!!!!!!! Team: " + team + " has GameSuspended!")
 
-                # temporary
-                print_risk_sequences(selected_probabilities)
-
             # if it's end of file, close the graph of the current team if
             # it's in the START state (which means the team is in at least 1 actual state)
             if first_cell == "END" and team in TEAMS and team in STATES[0]['user_ids']:
@@ -741,9 +685,6 @@
                 # clear the mining tools
                 MINING_TOOLS.clear()
 
-                # temporary
-                print_risk_sequences(selected_probabilities)
-
     # ------ RETURN RESULTS
     # generate lists from dictionaries
     state_list = list(STATES.values())
@@ -767,12 +708,6 @@
             'setting': 'test'}
 
 
-def print_risk_sequences(selected_probabilities):
-    if selected_probabilities.__len__() > 0:
-        for prob in selected_probabilities:
-            print(str(prob) + ",", end='')
-        print()
-
 def compute_similarities():
     # compute distances between trajectories
     similarity_criterium = "GoldSetup"
